---
layout: post
title: Locking on transactionID
tags:
	- PostgreSQL
	- Lock
---

PostgreSQLを運用している人は一度は見たことがあるpg\_lockシステムビュー。これは、PostgreSQLのロック情報を確認できるビューであり、、誰がどのようなオブジェクトに対し、どの種類のロックを取得しているのかまたは取得できずに待っているのかを確認することができます。pg\_lockを見てみると、トランザクションIDへロックを取得している様子を見ることができますが、トランザクションIDへのロックとはどのようなもので、なぜそのようなことをする必要があるのか、を解説します。

```
=# SELECT locktype, database, relation, page, tuple transactionid, mode, granted FROM pg_locks;
   locktype    | database | relation | page | transactionid |       mode       | granted
---------------+----------+----------+------+---------------+------------------+---------
 relation      |    13260 |    24851 |      |               | RowExclusiveLock | t
 virtualxid    |          |          |      |               | ExclusiveLock    | t
 relation      |    13260 |    11668 |      |               | AccessShareLock  | t
 virtualxid    |          |          |      |               | ExclusiveLock    | t
 transactionid |          |          |      |               | ExclusiveLock    | t        --★トランザクションIDへのロック？
(5 rows)
```

# PostgreSQLのロックマネージャ
共有メモリ上にあるハッシュテーブルを使ってロックを管理する。だれがどのようなロックを取得しているかがわかる。
ロックの対象となるのは、データベース、リレーション、ページ、タプルなど様々あり、トランザクションIDもそのうちの一つ。

デッドロック検知もこのハッシュテーブルの情報を用いて行う。

# PostgreSQLの行ロック
PostgreSQLの行ロックはタプルのXMAXに自身のトランザクションIDを書き込むことで行う。

行ロックするときには、まずタプルのXMAXをみて、XMAXがからであれば書き込む。空でなければ（他のトランザクションIDが書かれている）、そのトランザクションの状態を確認する。すでに終了済みであれば、すでに解放済みなのでロックが取得できる。
まだ実行中の場合は、そのトランザクションがCOMMITまたはABORTするまで待つ。

ただ、単純にSLEEPとかして待つわけにはいかず、Deadlockの可能性もあるので、共有メモリ上にあるロックテーブルへその情報を登録する必要がある。「○○タプルのロックを待っている」という情報を登録しても良いが、各トランザクションは大量のタプルに対してロックを取得することもあり、それを考えるとメモリがいくらあっても足りない。メモリを節約するために、ロックのプロモーションを行うもありだが、そうするとロックの粒度が大きくなって性能が出ない。

それを解決するために、PostgreSQLではトランザクションIDへのロックを利用している。

# トランザクションIDへのロック
全てのトランザクションはトランザクション開始時に自身のトランザクションIDに対して排他ロック(ExclusiveLocK)を取得し、トランザクション完了時に開放する。そして、トランザクションの完了を待つトランザクションは、待つ対象音トランザクションのトランザクションIDに対して共有ロック(ShareLock)を取得する。そして、共有ロックが取得できたということは、対象のトランザクションが終了したことを意味するので、共有ロックの獲得を待つことは、トランザクションの完了を待つことと同じ意味になる。共有ロックを取得した後は、ロックを開放する。


# トランザクション完了の順番待ち
