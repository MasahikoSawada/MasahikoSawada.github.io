---
layout: post
title: トランザクションIDへのロックと行ロック
tags:
  - PostgreSQL
  - Lock
---

PostgreSQLが持つpg\_lockシステムビューは、PostgreSQLのロックマネージャが管理する情報を見ることができるビューであり、誰がどのようなオブジェクトに対し、どの種類のロックを取得しているのか、または取得できずに待っているのかを確認することができます。

データベース、テーブル、インデックス、行（タプル）はロックの対象としてイメージしやすいですが、PostgreSQLでは以下のように「トランザクションID」へのロックを利用します。

```sql
=# SELECT locktype, database, relation, page, tuple transactionid, mode, granted FROM pg_locks;
   locktype    | database | relation | page | transactionid |       mode       | granted
---------------+----------+----------+------+---------------+------------------+---------
 relation      |    13260 |    24851 |      |               | RowExclusiveLock | t
 virtualxid    |          |          |      |               | ExclusiveLock    | t
 relation      |    13260 |    11668 |      |               | AccessShareLock  | t
 virtualxid    |          |          |      |               | ExclusiveLock    | t
 transactionid |          |          |      |               | ExclusiveLock    | t        --★トランザクションIDへのロック？
(5 rows)
```

pg\_locksビューで見たことがない人も、もしかしたら以下のようなサーバロクを見たことがあるかもしれません。

```bash
LOG:  process 67234 still waiting for ShareLock on transaction 1252 after 1000.548 ms
DETAIL:  Process holding the lock: 41506. Wait queue: 67234.
CONTEXT:  while updating tuple (0,26) in relation "hoge"
```

先週末にこの辺を調べたので、本記事ではトランザクションIDへのロックとはどのようなもので、なぜそのようなことをする必要があるのか、を解説します。ツッコミ大歓迎です。

# PostgreSQLのロックマネージャ
PostgreSQLのロックマネージャは共有メモリ上にあるハッシュテーブル（ロックテーブル）を使って管理しています[^lmgr]。そのハッシュテーブルを確認することで、誰がどのようなロックを取得しているか等がわかります。

ロックの対象となるのは、データベース、リレーション、ページ、行など様々あり、トランザクションIDもそのうちの一つです。詳細は省きますが、デッドロック検知もこのロックテーブルの情報を用いて行います。

[^lmgr]:PostgreSQLは用途に応じてheavy-weight lock, light-weight lock, spin lockを使い分けるのですが、ここではheavy weight lockを対象としています。

# 行ロック
行ロックは、ロックマネージャに行ロックの情報を登録する（かつ、トランザクション終了までそれを保持し続ける）事でも実現可能なのですが、一つのトランザクションや一つのSQLで大量の行をロックする可能性があるので、ロックテーブルが大きくなり過ぎて、メモリがいくらあっても足りないので、単純に行ロックを登録して保持し続けることはしません。

そのかわりに、PostgreSQLはロック対象の行のXMAX[^xmax]に自身のXIDを書き込むことで行ロックを実現しています。
行ロックする時は、まず行のXMAXを見てXMAXが空であれば自身のXMAXを書き込みます。XMAXが空でなければ（つまり、他のトランザクションIDが書かれている）、そのトランザクションの状態を確認します。そして、そのトランザクションがすでに終了済みであれば、すでにロックは解放済みという事なので、行ロックが取得できます[^visible]。一方、まだ実行中の場合は、そのトランザクションがCOMMITまたはABORTするまで待つ。という感じで動きます。


[^xmax]:PostgreSQLのテーブルの各行には、その行の可視性等を判断するために2つのトランザクション(xmin, xmax)が格納されている
[^visible]:UPDATE済み（そのトランザクションから見えない）の行はそもそも行ロック対象にならないので、「自分が行ロックをしようとしている＋その行のXMAXにすでに記載がある」というのは、他のトランザクションが変更中/変更がabortした、ということになります。

## 行ロック待ち
行ロック待ちをするときには、自分が「行○○行ロック待っている」おという情報をロックマネージャに登録した上で待つ(sleep)する必要があります。でないと、前述の通り、デッドロック検知はロックテーブルを元に行なわれますので、デッドロック検知ができなくなってしまいます。

ですが、各行へのロック情報をロックマネージャに登録してしまうと、最初に懸念したように、ロックテーブルのサイズが大きくなりすぎてしまうので、ここでトランザクションIDへのロックを使います。

# トランザクションIDへのロック
全てのトランザクションは、トランザクション開始時（正確にはトランザクションID取得時）に自身のトランザクションIDに対して排他ロック(ExclusiveLocK)を取得し、そのロックはトランザクション完了時まで保持します。

そして、トランザクションの完了を待つトランザクションは、待つ対象のトランザクションのトランザクションIDに対して共有ロック(ShareLock)を要求します（待つ対象のトランザクションIDはXMAXに書いてある）。そのため、共有ロックを要求しているトランザクションが共有ロックが取得できたということは、対象のトランザクションが終了したことを意味します。
共有ロックを取得した後は、すぐにロックを開放します。

# トランザクション完了の順番待ち
行ロックをXMAXへの記入＋トランザクションIDへのロックで実現することにより、ロックテーブルを効率的に使うことができます。しかし、この方式だけだと、異なる行へのロック待ちも全て一つのトランザクションIDへのロック待ちに集約されてしまうので、行毎のロック待ち順序が守られません。PostgreSQLはロックスケジュールとしてFIFOを採用しているので、行毎にFIFOを守りたいです。

ここでようやく、行ロックが出てきます。PostgreSQLはトランザクションIDへのロックを行う前に、行への排他ロックを取得し、その情報はロックマネージャに登録します。つまり、まとめると、

1. 行への排他ロック
2. トランザクションIDへの共有ロック
3. トランザクションIDのロックを開放
4. XMAXに自身のトランザクションIDを書く
5. 行のロックを開放

という感じです。

# まとめ
* 行ロックは、XMAXへのトランザクションID書き込み＋αで実現している
* 行ロックのときにトランザクションIDへのロックが使われる
* 全トランザクションは、トランザクション開始時に自身のトランザクションIDに排他ロックを取得する
* サーバログにトランザクションIDへのロック待ちが出たらまずは行ロックを疑うのが吉
  * 2人目以降の行ロック待ちでは、ちゃんと「行ロックで待ってます」というメッセージがでる
```
LOG:  process 75098 still waiting for ExclusiveLock on tuple (0,26) of relation 16387 of database 13259 after 1000.363 ms
DETAIL:  Process holding the lock: 67234. Wait queue: 75098.
```

いろいろと細かい所は端折っていますが、大まかな流れはこんな感じのはず。

# 参考
* src/backend/access/heap/README.tuplock
* src/backend/storage/lmgr/lock.c
* src/backend/storage/lmgr/lmgr.c
